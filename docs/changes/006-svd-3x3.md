# 006 — 3×3 SVD

## Goal
Implement singular value decomposition for 3×3 matrices, needed for projecting rotation matrices onto SO(3) during pose estimation.

## Preconditions
- 003 complete: `mat33_mul`, `mat33_transpose` available

## Postconditions
- `U * diag(S) * V^T = M` for known test matrices (within 1e-10)
- U and V are orthogonal: `U^T * U = I`, `V^T * V = I`
- Singular values are non-negative and in descending order
- Identity matrix → S = (1, 1, 1)
- Rank-2 matrix → S[2] ≈ 0
- Diagonal matrix → singular values are absolute values of diagonal entries

## Description
Add to `math.rs`:

```rust
pub fn svd_3x3(m: &[f64; 9]) -> ([f64; 9], [f64; 3], [f64; 9])  // (U, S, V)
```

Implementation approach: Golub-Kahan bidiagonalization for 3×3 matrices.
1. Compute `M^T * M` (symmetric 3×3)
2. Find eigenvalues/eigenvectors of `M^T * M` → V, σ² values
3. Compute `U = M * V * diag(1/σ)`
4. Fix signs so det(U) = +1 and det(V) = +1

Alternative: Port the Jacobi SVD from the reference C implementation's `svd22.h` extended to 3×3. This is simpler and numerically stable for small matrices.

Used in pose estimation (change 044-046) for projecting onto SO(3).

## References
- `docs/detection-spec.md` §10 — SVD for projecting approximate rotation onto proper rotation
- `docs/reference-detection/homography.c` — SVD usage for rotation projection
- `docs/reference-detection/svd22.h` — 2×2 SVD helper used in reference
